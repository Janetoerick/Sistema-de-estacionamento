Model SysADLModel ; package SysADL.types { value type Int { } value type Boolean { }   value type Real { }            enum ComandoCancela { Abrir , Fechar }  value type Hora { } datatype Ticket { attributes : pago : Boolean ; id : String ; entrada : Hora ; } datatype VagasDisponiveis { attributes : tipo : Vaga ; quantidade : Int ; } value type String { } enum Vaga { Normal , Idoso , Deficiente , Gestante } } package ParkingSystemConnectors { import ParkingSystemPorts ; connector def DetectarPresencaCN { participants : ~ dpOPT : PresencaOPT ; ~ dpIPT : PresencaIPT ; flows :   Boolean from dpOPT to dpIPT }   connector def AcionarCancelaCN { participants : ~ acOPT : CancelaOPT ; ~ acIPT : CancelaIPT ; flows : ComandoCancela from acOPT to acIPT }  connector def TicketCN { participants : ~ pOPT : TicketOPT ; ~ pIPT : TicketIPT ; flows : Ticket from pOPT to pIPT }  connector def MonitorarVagasCN { participants : ~ mvOPT : QuantidadeDeVagasOPT ; ~ mvIPT : QuantidadeDeVagasIPT ; flows :  VagasDisponiveis from mvOPT to mvIPT } connector def DetectarPassagemCN { participants : ~ dpOPT : PassagemOPT ; ~ dpIPT : PassagemIPT ; flows : Boolean from dpOPT to dpIPT } } package ParkingSystemComponents { import ParkingSystemConnectors ; import ParkingSystemPorts ; import SysADL.types ; component def SistemaDeEstacionamento {  configuration { components :         AcionarCancelaCP : AcionarCancelaCP { using ports : accOPT : CancelaOPT ; } CancelaCP : CancelaCP { using ports : cCIPT : CancelaIPT ; } ImpressoraTicketCP : ImpressoraTicketCP { using ports : tITIPT : TicketIPT ; } InterfaceDeVagasCP : InterfaceDeVagasCP { using ports : qvIPT : QuantidadeDeVagasIPT ; } MaquinaPagamentoCP : MaquinaPagamentoCP { using ports : tTOPT : TicketOPT ; } SensorDePassagemCP : SensorDePassagemCP { using ports : pOPT : PassagemOPT ; } SensorDePresencaCP : SensorDePresencaCP { using ports : dOPT : PresencaOPT ; } SistemaDeControleCP : SistemaDeControleCP { using ports : pIPT : PresencaIPT ; cOPT : CancelaOPT ; qvOPT : QuantidadeDeVagasOPT ; cSCIPT : CancelaIPT ; pIPT : PassagemIPT ; tSCIPT : TicketIPT ; tSCOPT : TicketOPT ; } EscanerTicketCP : EscanerTicketCP { using ports : tETOPT : TicketOPT ; } connectors : dprSC : DetectarPresencaCN bindings dOPT = pIPT ; mvIV : MonitorarVagasCN bindings qvOPT = qvIPT ;   acSC : AcionarCancelaCN bindings accOPT = cSCIPT ; acC : AcionarCancelaCN bindings cOPT = cCIPT ; dpaSC : DetectarPassagemCN bindings pOPT = pIPT ; tSC : TicketCN bindings tTOPT = tSCIPT ; tIT : TicketCN bindings tSCOPT = tITIPT ; tETSC : TicketCN bindings tETOPT = tSCIPT ; } }
	component def SensorDePresencaCP { ports : dOPT : PresencaOPT ; }
	component def CancelaCP { ports : cIPT : CancelaIPT ; }
	component def MaquinaPagamentoCP { ports :   tTOPT : TicketOPT ; }
	component def SistemaDeControleCP { ports : pIPT : PresencaIPT ; cOPT : CancelaOPT ;   qvOPT : QuantidadeDeVagasOPT ; cIPT : CancelaIPT ; pIPT : PassagemIPT ; tOPT : TicketIPT ; tSCOPT : TicketOPT ; }
	component def InterfaceDeVagasCP { ports : qvIPT : QuantidadeDeVagasIPT ; }
	component def AcionarCancelaCP { ports : accOPT : CancelaOPT ; }
	component def SensorDePassagemCP { ports : pOPT : PassagemOPT ; } component def ImpressoraTicketCP { ports :  tITIPT : TicketIPT ; } component def EscanerTicketCP { ports : tETOPT : TicketOPT ; } } package ParkingSystemPorts { import SysADL.types ;   port def PresencaOPT { flow out Boolean } port def PresencaIPT { flow in Boolean }   port def CancelaIPT { flow in ComandoCancela } port def CancelaOPT { flow out ComandoCancela }       port def QuantidadeDeVagasIPT { flow in VagasDisponiveis } port def QuantidadeDeVagasOPT { flow out VagasDisponiveis } port def PassagemIPT { flow in Boolean } port def PassagemOPT { flow out Boolean } port def TicketIPT { flow in Ticket } port def TicketOPT { flow out Ticket } } Requirement ControlarCancelaRF ( 1 ) { text = "O sistema deve ser capaz de controlar a cancela."  Requirement ControlarCancelaAutomaticamenteRF ( 1.2 ) { text = "O sistema deve ser capaz de acionar a cancela."   derive EscanearTicketRF , FornecerTicketRF ; } Requirement ControlarCancelaManualmenteRF ( 1.1 ) { text = "O sistema deve permitir que um usuário autorizado acione a cancela manualmente." derive FecharCancelaRF , AbrirCancelaRF ; } } Requirement CapturarHorarioTicketRF ( 1.2.2 ) { text = "O sistema deve capturar o horário em que o ticket foi retirado." derive CalcularValorDoTicketRF ; } Requirement ExibirVagasRF ( 2.1 ) { text = "O sistema deve ser capaz de exibir a quantidade de vagas disponíveis de cada tipo." } Requirement MonitorarPresencaDeVeiculoRF ( 2.3 ) { text = "O sistema deve monitorar se há veículo em cada vaga."  derive InformarPresencaDeVeiculoRF ; } Requirement DisponibilidadeRNF ( 3 ) { text = "O sistema deve operar 24 horas por dia, 7 dias por semana." } Requirement VerificarStatusDoTicketRF ( 1.2.6 ) { text = "O sistema deve ser capaz de verificar os status do ticket." derive ConfirmarPamentoTicketRF ; } Requirement PagarTicketRF ( 1.2.4 ) { text = "O sistema deve permitir que o usuário pague o ticket." } Requirement CalcularValorDoTicketRF ( 1.2.3 ) { text = "O sistema deve calcular o valor total do ticket com base na hora de entrada e saída." derive PagarTicketRF ; } Requirement ConfirmarPamentoTicketRF ( 1.2.7 ) { text = "O sistema deve informar se o ticket está pago." derive AbrirCancelaRF ; } Requirement VerificarPassagemVeiculoRF ( 1.1.3 ) { text = "O sistema deve ser capaz de verificar se o veículo já passou pela cancela." derive FecharCancelaRF ; } Requirement InformarPresencaDeVeiculoRF ( 2.2 ) { text = "O sistema deve informar a presença de veículo na vaga." derive GerenciarVagasRF ; } Requirement GerenciarVagasRF ( 2 ) { text = "O sistema deve gerenciar a quantidade de vagas livres e ocupadas." derive ExibirVagasRF ; } Requirement AbrirCancelaRF ( 1.1.1 ) { text = "O sistema deve abrir a cancela." derive VerificarPassagemVeiculoRF ; } Requirement FecharCancelaRF ( 1.1.2 ) { text = "O sistema deve fechar a cancela." } Requirement EscanearTicketRF ( 1.2.5 ) { text = "O sistema deve escanear o ticket." derive VerificarStatusDoTicketRF ; } Requirement FornecerTicketRF ( 1.2.1 ) { text = "O sistema deve fornecer ao usuário um ticket de acesso." derive CapturarHorarioTicketRF , AbrirCancelaRF ; }